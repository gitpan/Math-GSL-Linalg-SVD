/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.19 from the
 * contents of SVD.xs. Do not edit this file, edit SVD.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "SVD.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "gsl.h"

typedef gsl_vector* Math__GSL__Linalg__SVD__Vector;
typedef gsl_vector* Math__GSL__Linalg__SVD__Matrix;
typedef gsl_eigen_symmv_workspace* Math__GSL__Linalg__SVD__Eigen;

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 24 "SVD.c"

XS(XS_Math__GSL__Linalg__SVD__Eigen_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Eigen_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Eigen::new", "package, n1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	package = (char *)SvPV_nolen(ST(0));
	size_t	n1 = (size_t)SvUV(ST(1));
	Math__GSL__Linalg__SVD__Eigen	RETVAL;
#line 19 "SVD.xs"
    RETVAL = gsl_eigen_symmv_alloc(n1);
#line 43 "SVD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GSL::Linalg::SVD::Eigen", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GSL__Linalg__SVD__Vector_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Vector_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Vector::new", "package, n1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	package = (char *)SvPV_nolen(ST(0));
	size_t	n1 = (size_t)SvUV(ST(1));
	Math__GSL__Linalg__SVD__Vector	RETVAL;
#line 32 "SVD.xs"
    RETVAL = gsl_vector_alloc(n1);
#line 68 "SVD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GSL::Linalg::SVD::Vector", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GSL__Linalg__SVD__Vector_vector_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Vector_vector_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Vector::vector_set", "v, i, x");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Math__GSL__Linalg__SVD__Vector	v;
	size_t	i = (size_t)SvUV(ST(1));
	double	x = (double)SvNV(ST(2));

	if (sv_derived_from(ST(0), "Math::GSL::Linalg::SVD::Vector")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    v = INT2PTR(Math__GSL__Linalg__SVD__Vector,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Vector::vector_set",
			"v", "Math::GSL::Linalg::SVD::Vector");
#line 42 "SVD.xs"
        gsl_vector_set( v, i, x);
#line 102 "SVD.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Math__GSL__Linalg__SVD__Vector_vector_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Vector_vector_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Vector::vector_get", "v, i");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Math__GSL__Linalg__SVD__Vector	v;
	size_t	i = (size_t)SvUV(ST(1));
	double	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Math::GSL::Linalg::SVD::Vector")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    v = INT2PTR(Math__GSL__Linalg__SVD__Vector,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Vector::vector_get",
			"v", "Math::GSL::Linalg::SVD::Vector");
#line 49 "SVD.xs"
    RETVAL = gsl_vector_get(v, i);
#line 135 "SVD.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GSL__Linalg__SVD__Matrix_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Matrix_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Matrix::new", "package, n1, n2");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	package = (char *)SvPV_nolen(ST(0));
	size_t	n1 = (size_t)SvUV(ST(1));
	size_t	n2 = (size_t)SvUV(ST(2));
	Math__GSL__Linalg__SVD__Matrix	RETVAL;
#line 64 "SVD.xs"
    RETVAL = gsl_matrix_alloc(n1 , n2);
#line 160 "SVD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GSL::Linalg::SVD::Matrix", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GSL__Linalg__SVD__Matrix_matrix_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Matrix_matrix_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Matrix::matrix_set", "m, i, j, x");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Math__GSL__Linalg__SVD__Matrix	m;
	size_t	i = (size_t)SvUV(ST(1));
	size_t	j = (size_t)SvUV(ST(2));
	double	x = (double)SvNV(ST(3));

	if (sv_derived_from(ST(0), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    m = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::matrix_set",
			"m", "Math::GSL::Linalg::SVD::Matrix");
#line 75 "SVD.xs"
        gsl_matrix_set( m, i, j, x);
#line 195 "SVD.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Math__GSL__Linalg__SVD__Matrix_matrix_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Matrix_matrix_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Matrix::matrix_get", "m, i, j");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Math__GSL__Linalg__SVD__Matrix	m;
	size_t	i = (size_t)SvUV(ST(1));
	size_t	j = (size_t)SvUV(ST(2));
	double	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    m = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::matrix_get",
			"m", "Math::GSL::Linalg::SVD::Matrix");
#line 83 "SVD.xs"
    RETVAL = gsl_matrix_get(m, i, j);
#line 229 "SVD.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GSL__Linalg__SVD__Matrix_SV_decomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Matrix_SV_decomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Matrix::SV_decomp", "m, M, v1, v2");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Math__GSL__Linalg__SVD__Matrix	m;
	Math__GSL__Linalg__SVD__Matrix	M;
	Math__GSL__Linalg__SVD__Vector	v1;
	Math__GSL__Linalg__SVD__Vector	v2;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    m = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp",
			"m", "Math::GSL::Linalg::SVD::Matrix");

	if (sv_derived_from(ST(1), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    M = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp",
			"M", "Math::GSL::Linalg::SVD::Matrix");

	if (sv_derived_from(ST(2), "Math::GSL::Linalg::SVD::Vector")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    v1 = INT2PTR(Math__GSL__Linalg__SVD__Vector,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp",
			"v1", "Math::GSL::Linalg::SVD::Vector");

	if (sv_derived_from(ST(3), "Math::GSL::Linalg::SVD::Vector")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    v2 = INT2PTR(Math__GSL__Linalg__SVD__Vector,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp",
			"v2", "Math::GSL::Linalg::SVD::Vector");
#line 95 "SVD.xs"
    RETVAL = gsl_linalg_SV_decomp ( m,  M,  v1, v2);
#line 292 "SVD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GSL__Linalg__SVD__Matrix_SV_decomp_mod); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Matrix_SV_decomp_mod)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Matrix::SV_decomp_mod", "m, X, M, v1, v2");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Math__GSL__Linalg__SVD__Matrix	m;
	Math__GSL__Linalg__SVD__Matrix	X;
	Math__GSL__Linalg__SVD__Matrix	M;
	Math__GSL__Linalg__SVD__Vector	v1;
	Math__GSL__Linalg__SVD__Vector	v2;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    m = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp_mod",
			"m", "Math::GSL::Linalg::SVD::Matrix");

	if (sv_derived_from(ST(1), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    X = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp_mod",
			"X", "Math::GSL::Linalg::SVD::Matrix");

	if (sv_derived_from(ST(2), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    M = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp_mod",
			"M", "Math::GSL::Linalg::SVD::Matrix");

	if (sv_derived_from(ST(3), "Math::GSL::Linalg::SVD::Vector")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    v1 = INT2PTR(Math__GSL__Linalg__SVD__Vector,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp_mod",
			"v1", "Math::GSL::Linalg::SVD::Vector");

	if (sv_derived_from(ST(4), "Math::GSL::Linalg::SVD::Vector")) {
	    IV tmp = SvIV((SV*)SvRV(ST(4)));
	    v2 = INT2PTR(Math__GSL__Linalg__SVD__Vector,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp_mod",
			"v2", "Math::GSL::Linalg::SVD::Vector");
#line 107 "SVD.xs"
    RETVAL = gsl_linalg_SV_decomp_mod ( m, X, M,  v1, v2);
#line 365 "SVD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GSL__Linalg__SVD__Matrix_SV_decomp_jacobi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Matrix_SV_decomp_jacobi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Matrix::SV_decomp_jacobi", "m, M, v1");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Math__GSL__Linalg__SVD__Matrix	m;
	Math__GSL__Linalg__SVD__Matrix	M;
	Math__GSL__Linalg__SVD__Vector	v1;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    m = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp_jacobi",
			"m", "Math::GSL::Linalg::SVD::Matrix");

	if (sv_derived_from(ST(1), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    M = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp_jacobi",
			"M", "Math::GSL::Linalg::SVD::Matrix");

	if (sv_derived_from(ST(2), "Math::GSL::Linalg::SVD::Vector")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    v1 = INT2PTR(Math__GSL__Linalg__SVD__Vector,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::SV_decomp_jacobi",
			"v1", "Math::GSL::Linalg::SVD::Vector");
#line 117 "SVD.xs"
    RETVAL = gsl_linalg_SV_decomp_jacobi ( m,  M,  v1);
#line 418 "SVD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GSL__Linalg__SVD__Matrix_Eigen_decomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GSL__Linalg__SVD__Matrix_Eigen_decomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Math::GSL::Linalg::SVD::Matrix::Eigen_decomp", "m, ev, em, ew");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Math__GSL__Linalg__SVD__Matrix	m;
	Math__GSL__Linalg__SVD__Vector	ev;
	Math__GSL__Linalg__SVD__Matrix	em;
	Math__GSL__Linalg__SVD__Eigen	ew;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    m = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::Eigen_decomp",
			"m", "Math::GSL::Linalg::SVD::Matrix");

	if (sv_derived_from(ST(1), "Math::GSL::Linalg::SVD::Vector")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    ev = INT2PTR(Math__GSL__Linalg__SVD__Vector,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::Eigen_decomp",
			"ev", "Math::GSL::Linalg::SVD::Vector");

	if (sv_derived_from(ST(2), "Math::GSL::Linalg::SVD::Matrix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    em = INT2PTR(Math__GSL__Linalg__SVD__Matrix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::Eigen_decomp",
			"em", "Math::GSL::Linalg::SVD::Matrix");

	if (sv_derived_from(ST(3), "Math::GSL::Linalg::SVD::Eigen")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    ew = INT2PTR(Math__GSL__Linalg__SVD__Eigen,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Math::GSL::Linalg::SVD::Matrix::Eigen_decomp",
			"ew", "Math::GSL::Linalg::SVD::Eigen");
#line 129 "SVD.xs"
    RETVAL = gsl_eigen_symmv ( m,  ev, em, ew);
#line 481 "SVD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Math__GSL__Linalg__SVD); /* prototype to pass -Wmissing-prototypes */
XS(boot_Math__GSL__Linalg__SVD)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXSproto("Math::GSL::Linalg::SVD::Eigen::new", XS_Math__GSL__Linalg__SVD__Eigen_new, file, "$$");
        newXSproto("Math::GSL::Linalg::SVD::Vector::new", XS_Math__GSL__Linalg__SVD__Vector_new, file, "$$");
        newXSproto("Math::GSL::Linalg::SVD::Vector::vector_set", XS_Math__GSL__Linalg__SVD__Vector_vector_set, file, "$$$");
        newXSproto("Math::GSL::Linalg::SVD::Vector::vector_get", XS_Math__GSL__Linalg__SVD__Vector_vector_get, file, "$$");
        newXSproto("Math::GSL::Linalg::SVD::Matrix::new", XS_Math__GSL__Linalg__SVD__Matrix_new, file, "$$$");
        newXSproto("Math::GSL::Linalg::SVD::Matrix::matrix_set", XS_Math__GSL__Linalg__SVD__Matrix_matrix_set, file, "$$$$");
        newXSproto("Math::GSL::Linalg::SVD::Matrix::matrix_get", XS_Math__GSL__Linalg__SVD__Matrix_matrix_get, file, "$$$");
        newXSproto("Math::GSL::Linalg::SVD::Matrix::SV_decomp", XS_Math__GSL__Linalg__SVD__Matrix_SV_decomp, file, "$$$$");
        newXSproto("Math::GSL::Linalg::SVD::Matrix::SV_decomp_mod", XS_Math__GSL__Linalg__SVD__Matrix_SV_decomp_mod, file, "$$$$$");
        newXSproto("Math::GSL::Linalg::SVD::Matrix::SV_decomp_jacobi", XS_Math__GSL__Linalg__SVD__Matrix_SV_decomp_jacobi, file, "$$$");
        newXSproto("Math::GSL::Linalg::SVD::Matrix::Eigen_decomp", XS_Math__GSL__Linalg__SVD__Matrix_Eigen_decomp, file, "$$$$");
    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

